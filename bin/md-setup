#!/bin/bash

#set -e表示一旦脚本中有命令的返回值为非0，则脚本立即退出，后续命令不再执行;
#set -o pipefail表示在管道连接的命令序列中，只要有任何一个命令返回非0值，则整个管道返回非0值，即使最后一个命令返回0.
export setCmd="set -eo pipefail"
$setCmd

#导出环境变量
export PATH=/opt/MonkeyDev/bin:/usr/local/bin:/usr/bin:/usr/sbin:/bin:/sbin:$PATH

#脚本名称和版本
export scriptName="${0##*/}"
export scriptVer="2.0"

#本地存储文件的目录
export MonkeyDevPath="/opt/MonkeyDev"
export backupFileExt=".MonkeyDev"

#获取用户名、用户组、用户目录、和profile文件
export userName="${SUDO_USER-$USER}"
export userGroup=`id -g $userName`
export userHome=`eval echo ~$userName`
#用户可能存在的profile文件
export bashProfileFiles=("$userHome/.zshrc" "$userHome/.bash_profile" "$userHome/.bashrc" "$userHome/.bash_login" "$userHome/.profile")

#获取临时文件名
export tempDirsFile="`mktemp -d -t $scriptName`/tempdirs"
touch "$tempDirsFile"

#把LANG变量从当前环境中删除
unset LANG

#出错退出
function cleanup()
{
	local exitCode=$?
	set +e
	trap - $signals
	removeTempData
	exit $exitCode
}

function panic()
{
	local exitCode=$1
	set +e
	shift
	[[ "$@" == "" ]] || echo "$@" >&2
	exit $exitCode
}

export signals="0 1 2 3 15"
#当shell接收到signals指定的信号时，执行cleanup命令
trap cleanup $signals

function removeTempData()
{
	local tempDirs
	if [[ -f "$tempDirsFile" ]]; then
		tempDirs=(`cat "$tempDirsFile"`)
		for td in "${tempDirs[@]}"; do
			rm -rf "$td" || true
		done
		rm -rf "`dirname $tempDirsFile`" || true
	fi
}
function getTempDir()
{
	$setCmd
	local tempDir
	tempDir=`mktemp -d -t $scriptName` || \
		panic $? "Failed to create temporary directory"
	echo "$tempDir" >> "$tempDirsFile" || \
		panic $? "Failed to echo into $tempDirsFile"
	echo "$tempDir"
}

#下载文件
function downloadFile() # args: sourceUrl, targetPath
{
	local sourceUrl="$1"
	local targetPath="$2"
	local curlPath

	mkdir -p "${targetPath%/*}" || \
		panic $? "Failed to make directory: ${targetPath%/*}"

	curlPath=`which curl` || \
		panic $? "Failed to get curl path"

	"$curlPath" --silent --insecure --output "$targetPath" "$sourceUrl" || \
		panic $? "Failed to download $sourceUrl to $targetPath"
}

#解压文件
function extractTar() # args: tarPath, outputPath
{
	local tarPath="$1"
	local outputPath="$2"
	
	tar -C "$outputPath" -zxf "$tarPath" || \
		panic $? "Failed to extract $tarPath to $outputPath"
}

#下载github文件
function downloadGithubTarball() # args: url, outputDir, title
{
	$setcmd

	local url="$1"
	local outputDir="$2"
	local title="$3"
	local tempDirForTar
	local tempDirForFiles
	local untardDir
	local tarFile="file.tar.gz"

	echo "Downloading $title from Github..."

	tempDirForTar=`getTempDir`
	tempDirForFiles=`getTempDir`
	
	downloadFile "$url" "$tempDirForTar/$tarFile"
	
	extractTar "$tempDirForTar/$tarFile" "$tempDirForFiles"

	untardDir=`find "$tempDirForFiles/"* -type d -depth 0` || \
		panic $? "Failed to get untar'ed directory name of $tempDirForTar/$tarFile"

	mkdir -p "$outputDir" || \
		panic $? "Failed to make directory: $outputDir"

	cp -fR "$untardDir/"* "$outputDir/"
}

#修改文件权限
function changeMode()
{
	local mode="$1"
	local target="$2"
	local recursive="$3"
	local options

	[[ $recursive != "true" ]] || \
		options="-R"

	if [[ -e "$target" ]]; then
		chmod $options "$mode" "$target" || \
			panic $? "Failed to change mode to $mode on $target"
	fi
}

#获取用户profile文件
function determineUserBashProfileFile()
{
	$setCmd

	local f
	local filePath
	
	for f in "${bashProfileFiles[@]}"; do
		if [[ -f "$f" ]]; then
			filePath="$f"
			echo "" >> "$f" || \
				panic $? "Failed to echo into $f"
			break
		fi
	done
	
	if [[ $filePath == "" ]]; then
		filePath="$bashProfileFiles"

		touch "$filePath" || \
			panic $? "Failed to touch $filePath"
			
		chown "$userName:$userGroup" "$filePath" || \
			panic $? "Failed to change owner-group of $filePath"
		
		changeMode 0600 "$filePath"
	fi
	
	# return #
	echo "$filePath"
}

#增加内容到文件
function addToFileIfMissing() # args: filePath, pattern, value
{
	local filePath="$1"
	local pattern="$2"
	local value="$3"
	local doesContain

	doesContain=`doesFileContain "$filePath" "$pattern"`
	
	[[ $doesContain == "true" ]] || \
		echo "$value" >> "$filePath" || \
			panic $? "Failed to echo into $filePath"	
}

#判断文件是否包含内容
function doesFileContain() # args: filePath, pattern
{
	$setCmd
	
	local filePath="$1"
	local pattern="$2"
	local perlValue
	local funcReturn
	
	perlValue=`perl -ne 'if (/'"$pattern"'/) { print "true"; exit; }' "$filePath"` || \
		panic $? "Failed to perl"

	if [[ $perlValue == "true" ]]; then
		funcReturn="true"
	else
		funcReturn="false"
	fi
	
	# return #
	echo $funcReturn
}

#获取SDK属性
function getSdkProperty()
{
	$setCmd

	local sdk="$1"
	local propertyName="$2"

	propertyValue=`xcodebuild -version -sdk $sdk $propertyName` || \
		panic $? "Failed to get $sdk SDK property $propertyName"

	[[ $propertyValue != "" ]] || \
		panic 1 "Value of $sdk SDK property $propertyName cannot be empty"

	# return #
	echo "$propertyValue"
}

#获取平台名
function getPlatformName()
{
	$setCmd

	local sdk="$1"
	local iosSdkPlatformPath
	local platformDir
	local platformName
	
	iosSdkPlatformPath=`getSdkProperty $sdk PlatformPath`	
	platformDir="${iosSdkPlatformPath##*/}"
	platformName="${platformDir%.*}"
	
	# return #
	echo "$platformName"
}

function writeDefaults()
{
	local plistPath="$1"	
	shift 1

	defaults write "${plistPath%.*}" "$@" || \
		panic $? "Failed to write defaults to $plistPath"
}

function copyFile()
{
	cp -f "$1" "$2" || \
		panic $? "Failed to copy file $1 to $2"
}

function requireBackup()
{
	[[ ! -f "$1" || -f "${1}${backupFileExt}" ]] || \
		copyFile "$1" "${1}${backupFileExt}"
}

function requireFile()
{
	local filePath="$1"
	local touchFileIfNotFound="$2"
	
	if [[ ! -f "$filePath" ]]; then
		if [[ $touchFileIfNotFound == "true" ]]; then
			touch "$filePath" || \
				panic $? "Failed to touch $filePath"	
		else
			panic 1 "File not found: $filePath"
		fi
	fi
}

#无证书
function modifySdkSettings()
{
	local sdk="$1"
	local iosSdkPath
	local sdkSettingsPList
	
	iosSdkPath=`getSdkProperty $sdk Path`

	#备份SDKSettings.plist
	sdkSettingsPList="$iosSdkPath/SDKSettings.plist"
	#确保文件存在
	requireFile "$sdkSettingsPList" false
	requireBackup "$sdkSettingsPList"

	#修改SDKSettings.plist
	writeDefaults "$sdkSettingsPList" DefaultProperties "-dict-add" CODE_SIGNING_REQUIRED "-string" NO
	writeDefaults "$sdkSettingsPList" DefaultProperties "-dict-add" ENTITLEMENTS_REQUIRED "-string" NO
	writeDefaults "$sdkSettingsPList" DefaultProperties "-dict-add" AD_HOC_CODE_SIGNING_ALLOWED "-string" YES
	
	# fix mode
	changeMode 0644 "$sdkSettingsPList"
}

#生成动态库
function addXcodeSpecs()
{
	local sdk="$1"
	local platformName="$2"
	local iosSdkPlatformPath
	local xcspecFileNamePrefix
	
	iosSdkPlatformPath=`getSdkProperty $sdk PlatformPath`
	
	# get *.xcspec filename prefix
	xcspecFileNamePrefix="$platformName"	
	[[ ! $xcspecFileNamePrefix =~ "Simulator" ]] || xcspecFileNamePrefix="iPhone Simulator "

	# backup *PackageTypes.xcspec
	iosPackagesTypesXCSpec="$iosSdkPlatformPath/Developer/Library/Xcode/Specifications/${xcspecFileNamePrefix}PackageTypes.xcspec"	
	requireFile "$iosPackagesTypesXCSpec" false
	requireBackup "$iosPackagesTypesXCSpec"

	# modify *PackageTypes.xcspec
	addXcodeSpec "$iosPackagesTypesXCSpec" "com.apple.package-type.mach-o-executable" '{"ProductReference":{"IsLaunchable":"YES","FileType":"compiled.mach-o.executable","Name":"\$(EXECUTABLE_NAME)"},"DefaultBuildSettings":{"EXECUTABLE_NAME":"\$(EXECUTABLE_PREFIX)\$(PRODUCT_NAME)\$(EXECUTABLE_VARIANT_SUFFIX)\$(EXECUTABLE_SUFFIX)","EXECUTABLE_PATH":"\$(EXECUTABLE_NAME)","EXECUTABLE_SUFFIX":"","EXECUTABLE_PREFIX":""},"Type":"PackageType","Name":"Mach-O Executable","Identifier":"com.apple.package-type.mach-o-executable","Description":"Mach-O executable"}'
	addXcodeSpec "$iosPackagesTypesXCSpec" "com.apple.package-type.mach-o-dylib" '{"ProductReference":{"IsLaunchable":"NO","FileType":"compiled.mach-o.dylib","Name":"\$(EXECUTABLE_NAME)"},"DefaultBuildSettings":{"EXECUTABLE_NAME":"\$(EXECUTABLE_PREFIX)\$(PRODUCT_NAME)\$(EXECUTABLE_VARIANT_SUFFIX)\$(EXECUTABLE_SUFFIX)","EXECUTABLE_PATH":"\$(EXECUTABLE_NAME)","EXECUTABLE_SUFFIX":"","EXECUTABLE_PREFIX":""},"Type":"PackageType","Name":"Mach-O Dynamic Library","Identifier":"com.apple.package-type.mach-o-dylib","Description":"Mach-O dynamic library"}'

	# backup *ProductTypes.xcspec
	iosProductTypesXCSpec="$iosSdkPlatformPath/Developer/Library/Xcode/Specifications/${xcspecFileNamePrefix}ProductTypes.xcspec"
	requireFile "$iosProductTypesXCSpec" false
	requireBackup "$iosProductTypesXCSpec"

	# modify *ProductTypes.xcspec
	addXcodeSpec "$iosProductTypesXCSpec" "com.apple.product-type.tool" '{"IconNamePrefix":"TargetExecutable","PackageTypes":["com.apple.package-type.mach-o-executable"],"Name":"Command-line Tool","Type":"ProductType","DefaultTargetName":"Command-line Tool","DefaultBuildProperties":{"REZ_EXECUTABLE":"YES","LIBRARY_FLAG_NOSPACE":"YES","FULL_PRODUCT_NAME":"\$(EXECUTABLE_NAME)","INSTALL_PATH":"\/usr\/bin","CODE_SIGNING_ALLOWED":"YES","GCC_INLINES_ARE_PRIVATE_EXTERN":"YES","GCC_SYMBOLS_PRIVATE_EXTERN":"YES","GCC_DYNAMIC_NO_PIC":"NO","FRAMEWORK_FLAG_PREFIX":"-framework","ENTITLEMENTS_ALLOWED":"YES","STRIP_STYLE":"all","EXECUTABLE_PREFIX":"","MACH_O_TYPE":"mh_execute","EXECUTABLE_SUFFIX":"","LIBRARY_FLAG_PREFIX":"-l"},"Identifier":"com.apple.product-type.tool","Class":"PBXToolProductType","Description":"Standalone command-line tool"}'
	addXcodeSpec "$iosProductTypesXCSpec" "com.apple.product-type.library.dynamic" '{"IconNamePrefix":"TargetLibrary","PackageTypes":["com.apple.package-type.mach-o-dylib"],"Description":"Dynamic library","Type":"ProductType","DefaultBuildProperties":{"EXECUTABLE_SUFFIX":".\$(EXECUTABLE_EXTENSION)","PRIVATE_HEADERS_FOLDER_PATH":"\/usr\/include","REZ_EXECUTABLE":"YES","FULL_PRODUCT_NAME":"\$(EXECUTABLE_NAME)","LD_DYLIB_INSTALL_NAME":"\$(DYLIB_INSTALL_NAME_BASE:standardizepath)\/\$(EXECUTABLE_PATH)","DYLIB_COMPATIBILITY_VERSION":"1","INSTALL_PATH":"\/usr\/lib","FRAMEWORK_FLAG_PREFIX":"-framework","LIBRARY_FLAG_NOSPACE":"YES","GCC_INLINES_ARE_PRIVATE_EXTERN":"YES","CODE_SIGNING_ALLOWED":"YES","STRIP_STYLE":"debugging","EXECUTABLE_EXTENSION":"dylib","MACH_O_TYPE":"mh_dylib","DYLIB_CURRENT_VERSION":"1","PUBLIC_HEADERS_FOLDER_PATH":"\/usr\/include","DYLIB_INSTALL_NAME_BASE":"\$(INSTALL_PATH)","LIBRARY_FLAG_PREFIX":"-l"},"DefaultTargetName":"Dynamic Library","Class":"PBXDynamicLibraryProductType","Name":"Dynamic Library","Identifier":"com.apple.product-type.library.dynamic"}'
}

function addXcodeSpec()
{
	local specFile="$1"
	local specId="$2"
	local specData="$3"
	local fileContainsSpecId
	local tempDir
	local tempFile
	local defaultsRead
	
	fileContainsSpecId=`doesFileContain "$specFile" "$specId"`
	
	if [[ $fileContainsSpecId == "false" ]]; then
			
		tempDir=`getTempDir`		
		tempFile="$tempDir/`basename $specFile`.plist"
				
		plutil -convert json -o "$tempFile" "$specFile" || \
			panic $? "Failed to convert XCSpec file $specFile to JSON to temporary file $tempFile"
		
		perl -i -pe 's/\]$/,'"$specData"'\]/' "$tempFile" || \
			panic $? "Failed to add XCSpec to temporary file $tempFile"
		
		plutil -convert binary1 "$tempFile" || \
			panic $? "Failed to convert temporary file $tempFile to binary"

		copyFile "$tempFile" "$specFile"
	fi
}

function readDefaultsValue()
{
	$setCmd
	
	local plistPath="$1"
	local propertyName="$2"
	local value
	
	value=`defaults read "${plistPath%.*}" "$propertyName"` || \
		panic $? "Failed to read defaults property $propertyName from $plistPath"

	# return #
	echo "$value"
}

function addSymlinksToPathAvailableDuringBuilds()
{
	local sdk="$1"
	local iosSdkPlatformPath

	iosSdkPlatformPath=`getSdkProperty $sdk PlatformPath`
	
	#增加文件符号链接，以便在Xcode运行脚本的时候能找到
	createSymlink "$MonkeyDevPath/bin/iosod" "$iosSdkPlatformPath/Developer/usr/bin/iosod"
	createSymlink "$MonkeyDevPath/bin/ldid" "$iosSdkPlatformPath/Developer/usr/bin/ldid"
}

function createSymlink()
{
	local sourcePath="$1"
	local linkPath="$2"
	
	rm -f "$linkPath" || \
		panic $? "Failed to remove file: $linkPath"
	
	ln -fhs "$sourcePath" "$linkPath" || \
		panic $? "Failed to create symbolic link $linkPath -> $sourcePath"
}

#已经没什么卵用了
function createSdkPrivateHeaderSymlinks()
{
	local sdk="$1"
	local iosSdkPath
	local privateFWsDir
	local privateFwBinaries
	local fullPath
	local shortPath
	local sourcePath
	local targetPath

	iosSdkPath=`getSdkProperty $sdk Path`
	
	[[ -d "$iosSdkPath" ]] || \
		panic 1 "SDK directory not found: $iosSdkPath"
		
	privateFWsDir="$iosSdkPath/System/Library/PrivateFrameworks"
	
	[[ -d "$privateFWsDir" ]] || \
		panic 1 "PrivateFramework directory not found: $privateFWsDir"

	privateFwBinaries=($(find "$privateFWsDir" -type f -perm +111 -ipath "*.framework/*"))
	
	for f in "${privateFwBinaries[@]}"; do
		fullPath=`dirname "$f"`
		shortPath="${fullPath/#$privateFWsDir}"
		
		sourcePath="${MonkeyDevPath}/frameworks${shortPath}/Headers"
		targetPath="${fullPath}/Headers"
		
		if [[ -d "$sourcePath" ]] && [[ ! "$sourcePath" -ef "$targetPath" ]]; then
			if [[ -L "$targetPath" ]]; then
				echo "Symlink already exists: $targetPath"
			elif [[ -e "$targetPath" ]]; then
				echo "File or directory already exists: $targetPath"
			else
				createSymlink "$sourcePath" "$targetPath"
			fi
		fi
	done
}

function requireOptionValue()
{
	[[ "$2" != "" ]] || \
		panic 1 "Missing value for $1 option"
}

function showUsage()
{
	panic 1 \
"$scriptName (v${scriptVer}) -- MonkeyDev Setup
Usages:
   $scriptName base
   $scriptName sdk [-sdk <sdk>] [-d <directory>] [-which]

Arguments:
   base               Set up MonkeyDev base and Xcode templates.

   sdk                Set up latest iOS SDK for \"open\" development.

Options:
   -sdk <sdk>         SDK name and, optionally, version as one word to set
                      up. If version is omitted, latest version of named SDK
                      is used. If <sdk> is entirely omitted, latest iOS SDK is
                      used.

   -d <directory>     Set environment variable DEVELOPER_DIR to <directory> to
                      target specific Developer Tools. Use this option when
                      multiple versions of Xcode are installed.

   -which             Print which SDK and Developer Tools directory will be
                      used by default if -sdk <sdk> and -d <directory> are
                      not used.
"
}

#获取当前Xcode目录
devToolsDir="`xcode-select --print-path`" || \
	panic $? "Failed to get Xcode developer directory"
	
if [[ ! -d "$DEVELOPER_DIR" ]] && [[ -d "$devToolsDir" ]]; then
	export DEVELOPER_DIR="$devToolsDir"
fi

case "$1" in

base)
	# 创建/opt/MonkeyDev
	mkdir -p "$MonkeyDevPath" || \
		panic $? "Failed to make directory: $MonkeyDevPath"

	#下载一些基础文件和模板文件
	downloadGithubTarball "https://codeload.github.com/AloneMonkey/MonkeyDev/tar.gz/master" "$MonkeyDevPath" "MonkeyDev base"
	downloadGithubTarball "https://codeload.github.com/AloneMonkey/MonkeyDev-Xcode-Templates/tar.gz/master" "$MonkeyDevPath/templates" "Xcode templates"

	#创建空的frameworks目录
	mkdir -p "$MonkeyDevPath/frameworks" || \
		panic $? "Failed to make directory: $MonkeyDevPath/frameworks"

	#创建符号链接
	echo "Creating symlink to Xcode templates..."
	
	#$userHome/Library/Developer/Xcode/Templates/MonkeyDev linkto $MonkeyDevPath/templates
	userDevDir="$userHome/Library/Developer"
	userTemplatesDir="$userDevDir/Xcode/Templates"
	
	if [[ ! -d "$userTemplatesDir" ]]; then
		mkdir -p "$userTemplatesDir" || \
			panic $? "Failed to make directory: $userTemplatesDir"
			
		chown -R "$userName:$userGroup" "$userDevDir" || \
			panic $? "Failed to change ownership-group of $userDevDir"
	fi
	
	ln -fhs "$MonkeyDevPath/templates" "$userTemplatesDir/MonkeyDev"
	
	#修改用户profile文件
	echo "Modifying Bash personal initialization file..."
	
	userBashProfileFile=`determineUserBashProfileFile`

	addToFileIfMissing "$userBashProfileFile" "^(export)? *MonkeyDevPath=.*" "export MonkeyDevPath=$MonkeyDevPath"
	addToFileIfMissing "$userBashProfileFile" "^(export)? *MonkeyDevDevice=.*" "export MonkeyDevDevice="
	addToFileIfMissing "$userBashProfileFile" "^(export)? *PATH=.*(\\\$MonkeyDevPath\\/bin|${MonkeyDevPath//\//\\/}\\/bin).*" "export PATH=$MonkeyDevPath/bin:\$PATH"
;;
	
sdk)
	
	shift 1
	
	sdk="iphoneos" # default to latest iphoneos sdk
	printWhich="false"
	
	while [[ $1 != "" ]]; do
	case "$1" in
		-sdk)
			requireOptionValue "$1" "$2"
			sdk="$2"
			shift 2
		;;
		-d)
			requireOptionValue "$1" "$2"
			export DEVELOPER_DIR="$2"
			
			[[ -d "$DEVELOPER_DIR" ]] || \
				panic 1 "Directory not found: $DEVELOPER_DIR"

			shift 2
		;;
		-which)
			printWhich="true"
			shift 1
		;;
		*) panic 1 "Invalid option: $1" ;;
	esac
	done

	#获取SDK平台名字和版本
	platformName=`getPlatformName "$sdk"`
	sdkVersion=`getSdkProperty "$sdk" "SDKVersion"`
	
	[[ "$printWhich" == "false" ]] || \
		panic 1 "SDK: ${platformName}${sdkVersion}
Developer Tools: $DEVELOPER_DIR"

	echo "Setting up $platformName $sdkVersion SDK..."

	#修改SDK设置
	echo "Modifying SDK settings..."
	#modifySdkSettings "$sdk"
	
	#把MonkeyDev下的frameworks 创建符号链接到系统的privateframeworks
	echo "Symlinking to private frameworks header files..."
	#createSdkPrivateHeaderSymlinks "$sdk"

	#增加Xcode specifications
	echo "Adding specifications to platform..."
	#addXcodeSpecs "$sdk" "$platformName"

	# create symlinks so be available in PATH during Xcode builds
	echo "Creating symlinks in platform bin..."
	#addSymlinksToPathAvailableDuringBuilds "$sdk"
;;

*) showUsage ;;
esac

# done #

exit 0
